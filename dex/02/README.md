# AMM 原理：恒定乘积公式

## 什么是 AMM

自动化做市商（Automated Market Maker，AMM）是一种去中心化交易机制，用来代替传统的订单簿系统。在上一篇中，我们已经简单介绍了 AMM 的概念，这里将深入探讨其核心原理。传统的订单簿交易依赖于买卖双方匹配订单，而 AMM 则通过算法自动确定交易价格，用户无需等待交易对手，直接与流动性池进行交互。

AMM 机制的一个核心优势是消除了交易对手的匹配难度，使得交易更加便捷和流畅。

## AMM 的定价难题

在传统的中心化交易所中，价格发现依赖于订单簿机制。订单簿记录了所有买卖订单，价格由买方和卖方的供需情况决定，通过撮合引擎来匹配相应的订单。当供需发生变化时，价格也会相应调整。这种机制要求交易所具备高效的撮合引擎，并且需要大量的用户挂单，才能维持市场的流动性。

然而，对于去中心化交易所 (DEX) 而言，由于没有中心化的撮合引擎，无法依赖订单簿机制来实现价格发现。同时，DEX 的用户数量和流动性相对较少，如果仍使用订单簿机制，很可能出现交易对手不足、订单难以成交的问题。因此，我们需要一种能自动做市的机制，保证链上交易能及时完成，即 AMM 自动做市商机制。

AMM 的最大难点是如何实现价格发现机制。订单簿模式将这一功能交给市场，买卖双方各自出价，匹配上即能成交。但 AMM 买卖双方并不在同一时间进行交易，如何定价便成为了难题。

### 简单的设想，利用汇率构建价格

我们先用最简单的办法来定价，利用汇率构建价格：

```math
Px = y / x,
Py = x / y
```

`x` 和 `y` 代表两个代币的数量，`Px` 和 `Py` 代表价格。

这是一个简单且符合直觉的设想，却存在着很大的问题。

假设我们用 2000 个 token 和 1000 个 ETH 创建了一个流动性池，此时 1 个 token 等于 0.5 个 eth，1 个 ETH 等于 2 个 token。

```math
Ptoken = 1000 / 2000 = 0.5,
Peth = 2000 / 1000 = 2
```

目前还未出现问题，但是如果我们使用该池子做交易，将 2000 个 token 交换成 ETH 会发生什么？
我们将获得 1000 个 eth，这可是池子里所有的 ETH， **池子被抽干了！**

我们再来看看定价公式，上述定价公式实际上组成了一个和为恒定值的函数。

```math
Msum  = Mx + My = Px * x + Py * y
```

`Msum` 代表两个代币的市值总和，`Mx` 和 `My` 代表两个代币的价值，价值等于 `价格 * 数量`。

```math
Msum  = (y / x) * x + (x / y) * y = y + x = x + y
```

我们把之前的价格公式带入其中，就会发现总市值实际上就是两者的数量之和 `x + y`。
即 `x + y = k`, `k` 为常数，其函数图形如下：

![x + y = k](https://github.com/0x-stan/Education-Platform-Tutorial/raw/main/dex/02/img/uniswap-v1-like-01.png)

x 轴和 y 轴分别代表了两个代币在池内的数量，函数穿过 x 轴和 y 轴，根据图形可以很直观的看出这个公式允许 `x` 和 `y` 其中一个为 0！

这也就解释了为何我们用 2000 个 token 交换成 eth，流动性会枯竭的原因。

## 恒定乘积公式 (x \* y = k)

AMM 的核心机制就是恒定乘积公式，即 `x * y = k`，这是最常见的 AMM 定价模型之一，被 Uniswap 等去中心化交易所广泛采用。这里的 `x` 和 `y` 代表流动性池中两种不同 Token 的数量，而 `k` 是一个恒定的值，表示池中这两种 Token 数量的乘积始终不变。

```math
x∗y=k
```

每一笔交易都会改变两个代币的数量，无论数量如何变化，`k` 都应该保持不变。

$$(x + \Delta x)(y - \Delta y) = xy$$

这里的意思是用 `Delta x` 数量的`token x` 交换出 `Delta y` 数量的 `token y`。所以计算 `Delta y` 的公式为：

$$\Delta y = \frac{y \Delta x} {x + \Delta x}$$

请注意，我们现在得到的 `Delta y` 是数量而不是价格。

![x * y = k](https://github.com/0x-stan/Education-Platform-Tutorial/raw/main/dex/02/img/uniswap-v1-like-02.png)

由上图看出来，乘积恒定的函数是一个双曲线，不会与 x 轴或 y 轴相交，这使得流动性近乎无限。

还有一个有趣的特征，双曲线价格函数会导致价格滑点。**购买量越大，价格滑点越高，得到的越少。**

### 示例：三笔交易描述池内 Token 变化

1. **初始状态**：

   - 池中有 100 个 ETH 和 10,000 个 USDC。
   - `k = 100 * 10,000 = 1,000,000`
   - 初始价格：`USDC/ETH = 10,000 / 100 = 100`

2. **交易 1：用 1,000 USDC 购买 ETH**

   - Alice 用 1,000 USDC 交换池中的 ETH。
   - 新的 USDC 数量：`10,000 + 1,000 = 11,000`
   - 新的 ETH 数量：`k / y = 1,000,000 / 11,000 ≈ 90.91`
   - 交易后的价格：`USDC/ETH = 11,000 / 90.91 ≈ 121`

3. **交易 2：用 2 个 ETH 购买 USDC**

   - Bob 用 2 个 ETH 交换池中的 USDC。
   - 新的 ETH 数量：`90.91 + 2 = 92.91`
   - 新的 USDC 数量：`k / x = 1,000,000 / 92.91 ≈ 10,764.71`
   - 交易后的价格：`USDC/ETH = 10,764.71 / 92.91 ≈ 115.87`

4. **交易 3：用 500 USDC 购买 ETH**

   - Alice 用 500 USDC 交换池中的 ETH。
   - 新的 USDC 数量：`10,764.71 + 500 = 11,264.71`
   - 新的 ETH 数量：`k / y = 1,000,000 / 11,264.71 ≈ 88.77`
   - 交易后的价格：`USDC/ETH = 11,264.71 / 88.77 ≈ 126.93`

### 交易变化表格

| 交易次数 | 池中 ETH 数量 | 池中 USDC 数量 | 恒定乘积 (k) | 交易价格 (USDC/ETH) |
| -------- | ------------- | -------------- | ------------ | ------------------- |
| 初始状态 | 100           | 10,000         | 1,000,000    | 100                 |
| 交易 1   | 90.91         | 11,000         | 1,000,000    | 121                 |
| 交易 2   | 92.91         | 10,764.71      | 1,000,000    | 115.87              |
| 交易 3   | 88.77         | 11,264.71      | 1,000,000    | 126.93              |

这种机制确保了 Token 价格随着交易量的变化而动态调整，反映出市场供需关系。越多的人购买某种 Token，该 Token 在池中的数量就越少，价格自然会提高。

## 流动性池 (Liquidity Pool)

流动性池是 AMM 的基础，池中包含了两种不同的 Token（例如 ETH 和 USDC）。流动性池的存在使得用户可以随时进行交易，而不需要与另一个交易者直接匹配。

任何人都可以成为流动性提供者（LP），只需将等值的两种 Token 存入池中。例如，如果你想为 ETH/USDC 池提供流动性，就需要存入相同价值的 ETH 和 USDC。当其他人通过该池进行交易时，你将获得一部分交易手续费作为奖励。

假如 Alice 向 ETH/USDC 流动性池中添加了 10 个 ETH 和 1,000 USDC，由于添加的两种资产需要等值，因此 Alice 的添加符合 AMM 的要求。添加后，Alice 拥有该流动性池的一部分份额。

接下来，Bob 决定向池中添加不同数量的流动性。假如 Bob 添加了 5 个 ETH 和 1,200 USDC，由于添加的两种资产不完全等值，因此他需要调整添加量以确保两种资产的价值相等。假设最终 Bob 添加了 5 个 ETH 和 500 USDC，这样他也成为了流动性提供者。

### 流动性池状态

| 添加者   | 池中 ETH 数量 | 池中 USDC 数量 | 备注                 |
| -------- | ------------- | -------------- | -------------------- |
| 初始状态 | 0             | 0              | 无初始流动性         |
| Alice    | 10            | 1,000          | 等值添加流动性       |
| Bob      | 5             | 500            | 调整后等值添加流动性 |

## 交易手续费

上述情况我们并没有考虑手续费的影响，交易手续费是流动性提供者的主要收入来源，同时也为整个系统的稳定性提供了激励机制。每笔交易都会产生一定比例的手续费，这部分手续费直接分配给流动性提供者，以奖励他们提供的流动性。

在 Uniswap 中，手续费的被设计为一个固定的费率，例如每笔交易的手续费为 0.3%（在 Uniswap V3 可以设置多档费率）。当用户进行代币交换时，这 0.3% 的手续费会添加到流动性池中，并按流动性提供者的份额比例分配给他们。

### 示例

假设 Alice 和 Bob 共同为 ETH/USDC 流动性池提供流动性，共有 100 个 ETH 和 10,000 个 USDC。在此基础上，如果有一个用户使用 1,000 USDC 购买 ETH，交易产生的 0.3% 手续费会自动在输出资产中扣取，添加到池中并变成流动性的一部分。

交易后池中的状态为：

- 新的 USDC 数量：`11,000`（含 1,000 USDC 交易额）
- 新的 ETH 数量 90.94：
  - `根据恒定乘积公式计算交易后 ETH 数量：`k / y = 1,000,000 / 11,000 ≈ 90.91\`
  - 交易输出数量：`100 - 90.91 ≈ 9.09` ETH
  - 手续费：`9.09 * 0.3% ≈ 0.0273` ETH
  - 手续费添加后池中 ETH 数量：\`90.91 + 0.0273 = 90.9373\`

这 0.0273 ETH 手续费会按照 Alice 和 Bob 的流动性份额进行分配。

## 无常损失 (Impermanent Loss)

流动性提供者在 AMM 中可能面临的一大风险就是无常损失（Impermanent Loss）。无常损失是指，当流动性提供者将资产存入流动性池后，由于市场价格波动，导致其资产相对于直接持有这些资产时的价值减少。

举个例子，假设你在 ETH/USDC 流动性池中存入了 100 个 ETH 和 10,000 USDC，当时 ETH 的市场价格是 100 USDC。

- **初始状态**：

  - ETH 数量：100
  - USDC 数量：10,000
  - 总价值：100 ETH \* 100 USDC/ETH + 10,000 USDC = 20,000 USDC

- **价格上涨至 150 USDC**：

  - 由于 ETH 价格上涨，流动性池中 ETH 数量会减少，而 USDC 数量增加。
  - 根据恒定乘积公式 `x * y = k`，我们有 `100 * 10,000 = 1,000,000`。当 ETH 的价格上涨到 150 USDC 时，池中的资产数量：
    - ETH ：`81.65`
    - USDC ：`12,245`

- **无常损失计算**：

  - 设置一个对照组，假设直接持有 100 个 ETH 和 10,000 USDC，现在的总价值为：`100 * 150 + 10,000 = 25,000 USDC`
  - 流动性提供者在池中的资产价值为：
    - ETH 价值：`81.65 * 150 = 12,247.5 USDC`
    - USDC 价值：`12,245 USDC`
    - 总价值：`12,247.5 + 12,245 = 24,492.5 USDC`
  - 无常损失为：`25,000 - 24,492.5 = 507.5 USDC`

无常损失的产生是因为当资产价格发生变化时，池内资产的比例也会调整，以保持 `x * y = k` 恒定。在价格上涨或下跌时，池中剩余资产的组合往往相较于直接持有这些资产的价值更少，这种差值就是无常损失。不过，如果市场价格回到原来的水平，无常损失就会消失。

另外流动性提供者还有手续费收入，可以弥补无常损失。

## 恒定乘积公式的变种

虽然恒定乘积公式 (`x * y = k`) 是最常见的 AMM 定价模型，但在不同的应用场景中，AMM 公式也有一些变种。

例如，Curve 专注于稳定币交易，采用了一种改进的公式，使得价格变化更为平缓，特别适合于类似价值的资产交易，例如 USDC 和 DAI。这种变种公式在减少无常损失方面效果更好，因为它使得池中资产的价格波动较小。

Balancer 则是另一个例子，它允许一个流动性池中有多种 Token，且每种 Token 可以有不同的权重。这样可以实现更加灵活的资产配置和做市策略，适合那些希望在一个池中管理多种资产的流动性提供者。

总的来说，恒定乘积公式是 AMM 的核心，但为了适应不同的市场需求，AMM 也在不断演变和创新，形成了多种不同的模型，以满足去中心化金融（DeFi）中不断变化的需求。

在下一节我们将开始实现自己的 Uniswap 合约！

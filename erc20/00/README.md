# ERC20 概述

一个 ERC-20 代币是在以太坊网络上表示某种资产的代币。它可以是任何东西，例如：

- 在线平台中的信誉积分
- 游戏中一个角色的技能
- 彩票
- 金融资产类似于公司股份的资产
- 像美元一样的法定货币
- 一盎司黄金
- 及更多...

可以想象，如果每次有人想创建一个新的代币时，都要创建一个新的变体，其中包含不同的功能，这将非常令人头痛！这就相当于在开发网页应用程序时，每个网页都需要编写完全不同的 API 接口。ERC-20 标准的主要用途是提高生态系统的兼容性。像 Uniswap 这样的交易所能够构建一次并适用于任何符合 ERC-20 标准的代币。ERC-20 标准确保应用程序（例如交易所、钱包）可以一致地处理每种代币。ERC-20 代币的一个主要目标是最大限度地减少与集成其他代币时的摩擦。

## ERC-20 代币智能合约

在最基本的层面上，ERC-20 代币智能合约通常使用 `mapping` 来保存**可替代代币**的余额：一个代币等于任何其他代币，它们的价值相同且没有任何特殊权利或特征与之关联。

这种简单的 ERC-20 代币合约可以用于货币、质押、投票等中介功能。

在上一节中，我们编写了一个简单的 `Token` 合约：

```solidity
contract Token {
    mapping(address => uint) public balances;
}
```

这就像 `uint => uint` 映射一样简单，SDAU 智能合约（遵循 ERC-20 标准）基本上也是这样，主要通过映射代币持有量。

## ERC-20 代币接口

正如我们之前讨论的那样，ERC-20 定义了一个通用接口，任何应用程序都可以以标准方式与代币进行交互。以同样的方式，任何新项目都可以使用任何兼容 ERC-20 的应用程序（例如交易所）。这就是为什么我们为自己的代币实现 ERC-20 标准接口，以便它可以与其他项目兼容！

ERC-20 接口定义了一组必须在每个实现中存在的函数，该接口确保所有代币使用相同的函数来执行这些功能。这些函数包括但不限于：

- **名称、符号和小数位数**：标识代币的重要字段
- **`totalSupply`**：返回代币的总供应量
- **`balanceOf`**：返回给定地址的余额
- **`transfer`**：用于将代币从一方转移到另一方的主要函数

在 Solidity 中，你可以为自己的合约实现你自己的接口。为符合 ERC-20 标准，您可以通过简单地继承接口来实现它：

```solidity
contract MyContract is IERC20 {
    ...
}
```

## ERC-20 数据结构

通过 ERC-20 标准使用的 ERC-20 代币有三种重要的数据结构，我们应该回顾：

1. **余额**：跟踪每个地址的代币余额的映射。每次转账都会对一个余额进行扣减，另一个余额进行增加。
2. **允许**：用于记录被授权人可以代表代币持有人支配的代币数量的映射。此映射的键是所有者地址，值是另一映射（被授权地址和分配的金额）。
3. **已分配的金额**：可以在后续部分中进一步讨论这些限制。

## ERC-20 `transfer` 函数

在 ERC-20 兼容的智能合约中，没有其他方法可以更改余额：

- **`transfer`**：对 `transfer` 方法的调用直接调用合约的转账功能，只有一行代码。
- **`approve` 和 `transferFrom`**：有关如何结合使用 `approve` 和 `transferFrom` 的更多细节将在下一节中介绍！

## 建议阅读

- [ERC-20 代币标准](https://eips.ethereum.org/EIPS/eip-20)
- OpenZeppelin 的 ERC-20 智能合约实现
- [Chapter 5](https://book.ethereum.org/ch5) - Solidity 编程
- [OpenZeppelin ERC-20 Compliant Contracts](https://docs.openzeppelin.com/contracts/4.x/erc20)
